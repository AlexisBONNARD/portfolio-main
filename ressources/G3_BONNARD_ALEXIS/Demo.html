<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DS_TD3_BONNARD_ALEXIS</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>
    <script>
        var config = {
            type: Phaser.AUTO,
            width: 1024,
            height: 576,
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            scale:{
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            },
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 300 },
                    debug: true
                    //a métre en false
                }
            }
        };

        var game = new Phaser.Game(config);

        function preload ()
        {
            this.load.tilemapTiledJSON('map1', 'assets/map/tile-collision-test - Copie.json');
            this.load.image('pic','assets/image/spike.png');
            this.load.image('case','assets/image/case.png');
            this.load.spritesheet('ground_1x1','assets/image/ground_1x1.png', {frameWidth: 32, frameHeight: 32});
            this.load.spritesheet('dude','assets/image/dude1.png', {frameWidth: 19, frameHeight: 42});
            this.load.spritesheet('coin','assets/image/coin.png', {frameWidth: 32, frameHeight: 32});
            this.load.audio('fin','assets/sound/criMort.mp3');
            this.load.audio('fond','assets/sound/Niveaux_7_1.mp3');
            this.load.audio('degat','assets/sound/classic_hurt.mp3');
            this.load.audio('recup','assets/sound/ding.mp3');
            this.load.audio('cave','assets/sound/cave.mp3');
        }
        
        var platforms;
        var score = 0;
        var timerScore = 6000;
        var timerMusic = 0;
        var life = 300;
        var coin =  0
        var invincible = false;
        var compteurI = 0;
        var gameOver = false;  // Ajout d'une variable pour indiquer la fin du jeu
        var totalCoins = 28;  // Le nombre total de pièces à récupérer
        var remainingCoins = totalCoins;
        var gameWon = false;  // Pour savoir si le joueur a gagné

        //meckanique d'inversion
        var inverse = false;
        var couldawnInversion = 10;
        //timer
        var timerS;
        var timerM;
        var timerReste;
        
        function create(pointer, gameObject)
        {
            //map
            map = this.make.tilemap({ key: 'map1' });
            var groundTiles = map.addTilesetImage('ground_1x1');
            var coinTiles = map.addTilesetImage('coin');
            var picsTiles = map.addTilesetImage('pic');
            map.createLayer('Background Layer', groundTiles, 0, 0);

            groundLayer = map.createLayer('Ground Layer', groundTiles, 0, 0);
            coinLayer = map.createLayer('Coin Layer', coinTiles, 0, 0);
            picLayer = map.createLayer('Pics Layer', picsTiles, 0, 0);

            // collion avec les tuiles 1 à 25 : ground_1x1
            groundLayer.setCollisionBetween(1,25);

            // Set world bounds based on map size
            this.physics.world.setBounds(0, 0, map.widthInPixels, map.heightInPixels);


            //player
            player = this.physics.add.sprite(120, 450, 'dude');
            player.setBounce(0.2);
            player.setCollideWorldBounds(true);
            player.body.setGravityY(300);
            this.physics.add.collider(player,platforms);


            //colision joueur avec
            this.physics.add.collider(player, groundLayer);
            this.physics.add.overlap(player, coinLayer);
            this.physics.add.overlap(player, picLayer);

            
            //reaction lier au colition 
            coinLayer.setTileIndexCallback(26, hitCoin, this);
            picLayer.setTileIndexCallback(32, hitPic, this);
            
            //animation
            this.anims.create({
                key: 'left',
                frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),
                frameRate: 10,
                repeat: -1
            });
            this.anims.create({
                key: 'right',
                frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
                frameRate: 10,
                repeat: -1
            });
            this.anims.create({
                key: 'turn',
                frames: [{key: 'dude', frame: 4 }],
                frameRate: 20,
                repeat: -1
            });
            this.anims.create({
                key: 'leftInvers',
                frames: this.anims.generateFrameNumbers('dude', { start: 9, end: 13 }),
                frameRate: 10,
                repeat: -1
            });
            this.anims.create({
                key: 'rightInvers',
                frames: this.anims.generateFrameNumbers('dude', { start: 15, end: 18 }),
                frameRate: 10,
                repeat: -1
            });
            this.anims.create({
                key: 'turnInvers',
                frames: [{key: 'dude', frame: 14 }],
                frameRate: 20,
                repeat: -1
            });
            this.anims.create({
                key: 'coin1',
                frames: this.anims.generateFrameNumbers('coin', { start: 0, end: 5 }),
                frameRate: 10,
                repeat: -1
            });

            // définition de la fenêtre de la caméra
            this.cameras.main.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
            // la camera suit le joueur
            this.cameras.main.startFollow(player);


            // UI elements (health bar)
            rectBlack = this.add.rectangle(10, 10, 305, 30, '0x000000').setOrigin(0, 0);
            rectRed = this.add.rectangle(12.5, 12.5, life, 25, '0xff0000').setOrigin(0, 0);
            rectBlack.setScrollFactor(0);
            rectRed.setScrollFactor(0);

            // Ajouter un texte "Perdu" ou "Gagné" (invisible au départ)
            this.texteFin = this.add.text(400, 300, '', { fontSize: '32px', fill: '#FFF' }).setOrigin(0.5);
            this.texteFin.setScrollFactor(0);  // Le texte reste fixe
            
            // Ajouter un score
            this.textScore = this.add.text(500, 100, '', { fontSize: '32px', fill: '#FFF' }).setOrigin(0.5);
            this.textScore.setScrollFactor(0);  // Le texte reste fixe
            
            // Ajouter un timer
            this.timer = this.add.text(950, 50, '', { fontSize: '32px', fill: '#FFF' }).setOrigin(0.5);
            this.timer.setScrollFactor(0);  // Le texte reste fixe
        }

        function hitCoin (sprite, tile)
        {
            coinLayer.removeTileAt(tile.x, tile.y);
            score = score + 500;
            coin ++
            console.log(coin,"coin");
            this.textScore.setText(score/100 + " cagiteCase");
            this.sound.play("recup"); 
            timerScore = timerScore + 120;             
            
            if (coin == 2) { //212 piéce
                score = score + timerScore;
                this.textScore.setText(score/100 + " cagiteCase");
                this.texteFin.setText('Gagné !');
                gameWon =true;
                this.physics.pause(); 
            }
        }
        
        function hitPic (sprite, tile)
        {
            if (!invincible && !gameOver && !gameWon) {  // Vérifie si le jeu n'est pas fini
                if (life > 0) {                    
                    life = Math.max(life - 5, 0); 
                    rectRed.setSize(life, 25);     
                    invincible = true;            
                    player.setTint(0xff0000);                              
                    
                    this.time.delayedCall(250, () => {
                        invincible = false;
                        player.clearTint();
                    }, [], this);
                    timerScore = timerScore -60;
                    score = score -100;
                    this.textScore.setText(score/100 + " cagiteCase");
                    if (score > 25000 && life < 20) {
                        this.sound.play("cave");
                    }
                    else{
                        this.sound.play("degat");
                    }
                }
                
                if (life === 0) {
                    // Afficher "Perdu" si la vie tombe à 0 avant de récupérer toutes les pièces
                    this.texteFin.setText('Perdu');
                    this.sound.play("fin");
                    this.physics.pause();  
                    gameOver = true;   
                }
            }
        }


        function update ()
        {
            //timer diférent crémenté
            timerScore --;
            timerMusic--
            couldawnInversion --;

            // Si le jeu est en état "game over", on arrête le code de mouvement
            if (gameOver) 
            {
                return; 
            } // Ne plus autoriser aucune interaction
            timerM = Math.round(timerScore/3600,2)
            timerReste = timerScore-timerM*3600
            timerS = Math.round(timerReste/60,2)
            if (timerS<0)
            {
                timerM = timerM-1
                timerS = (timerS*-1)+30
            }
            //timer = math.Round(timer,1);
            this.timer.setText(timerM + " m " + timerS + " s");

            if (timerScore === 0) { // Afficher "Perdu" si le temps tombe à 0 avant de récupérer toutes les pièces
                this.texteFin.setText('Perdu');
                this.sound.play("fin");
                this.physics.pause();  
                gameOver = true;
            }
            
            if (timerMusic <= 0) {
                this.sound.play("fond");
                timerMusic = 48*60;
            }

            cursors = this.input.keyboard.createCursorKeys();

            if (cursors.up.isDown && player.body.onFloor()){
                player.setVelocityY(-500);
            }

            if (cursors.down.isDown && couldawnInversion <= 0){
                inverse = !inverse;
                if (inverse){
                    player.anims.play('turnInvers');
                    player.body.setGravityY(-300);
                }
                else{
                    player.anims.play('turn');
                    player.body.setGravityY(300);
                }
                couldawnInversion = 60;
            }
            if (cursors.left.isDown){
                player.setVelocityX(-180);
                if (inverse){
                    player.anims.play('leftInvers', true);
                }
                else{
                    player.anims.play('left', true);
                }
            }
            else if (cursors.right.isDown){
                player.setVelocityX(180);
                if (inverse){
                    player.anims.play('rightInvers', true);
                }
                else{
                    player.anims.play('right', true);
                }
            }
            else{
                player.setVelocityX(0);
                if (inverse){
                    player.anims.play('turnInvers');
                }
                else{
                    player.anims.play('turn');
                }
            }
        } 
    </script>
</body>